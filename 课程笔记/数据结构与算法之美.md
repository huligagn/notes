# 数据结构与算法之美

## 19 散列表（中）

- 散列函数不能太复杂，计算要快，同时可以结合数据进行特殊设计
- 装载因子过大，需要进行扩容，扩容意味着rehash
- 扩容可以一次性扩容，也可以分批次进行扩容
- 开放寻址法解决哈希冲突：cpu查询数组比链表快很多，链表序列化很慢；所以数据量比较小、装载因子比较小时可以用这种方式
- 拉链法解决哈希冲突：适合大对象、大数据量存储
- 如何设计一个散列表：考虑哈希函数、考虑装载因子和扩容机制、选择合适的冲突 解决方法

## 20 散列表（下）

- 链表实现LRU，如果数据在链表中就删除数据添加到头部，如果数据不在链表中判断是否满容再添加到头部；可以用散列表把`O(n)`的复杂度降低到`O(1)`：用散列表来查数据，数据同时构成链表
- redis的有序集合就用了跳表和散列表，key上增加散列表，value上增加跳表
- LinkedHashMap，如果指定参数按照访问时间排序，那么就是一个LRU

## 21 哈希算法（上）

- 哈希算法：等长、入参不同结果不同、无法反算、冲突概率小、快速
- 哈希算法应用：安全加密、唯一标志、数据校验、散列函数

## 22 哈希算法（下）

- 负载均衡，会话粘滞
- 数据分片：统计关键词数量，存在性判断
- 分布式存储，注意一致性哈希

## 23 二叉树基础（上）

- 树：根节点，叶子节点，父子节点，兄弟节点
- 高度（到叶子节点的最长路径），深度（根节点到这个节点的边数），层数（深度+1），树的高度（根节点的高度）
- 二叉树，N叉树
- 树的存储形式：顺序存储（数组）、链式存储（链表）
- 满二叉树，完全二叉树（完全二叉树可以用数组存储）
- 二叉树的遍历：前序、中序、后序，取决于父节点的顺序

## 24 二叉树基础（下）

